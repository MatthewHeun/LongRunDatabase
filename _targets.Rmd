---
title: "Long run database test"
author: "Matthew Kuperus Heun"
date: "27 Apr 2023"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```


# Setup

Load required packages.

```{r}
library(targets)
# remove the `_targets_r` directory previously written by non-interactive runs of the report.
tar_unscript()
```


# Globals

Define global options and functions.

```{targets example-globals, tar_globals = TRUE}
options(tidyverse.quiet = TRUE)
tar_option_set(packages = c("dplyr", "ggplot2", "readxl", "tidyr", "matsindf", "Recca"))

read_data <- function(.path, sheet) {
  .path |> 
    readxl::read_excel(sheet = sheet) 
}
```

# Targets

Load the raw Iron and steel data from Ricardo.

```{targets iron_steel, tar_simple = TRUE}
read_data("data/Iron_Steel_data_US_2011_2001.xlsx", sheet = "Iron and steel")
```

Process the data into a `matsindf` data frame, 
a.k.a., a magic spreadsheet.
First step is to make S_units vectors.

```{targets s_units, tar_simple = TRUE} 
iron_steel |> 
  dplyr::mutate(
    # Create a "Product" as expected when creating the S_units matrix.
    "{IEATools::iea_cols$product}" := dplyr::case_when(
      .data[["Matrix"]] %in% c("R", "V") ~ .data[["To"]], 
      .data[["Matrix"]] %in% c("U", "Y") ~ .data[["From"]], 
      TRUE ~ NA_character_
    ), 
    # Create a "Flow" as expected when creating the S_units matrix.
    "{IEATools::iea_cols$flow}" := dplyr::case_when(
      .data[["Matrix"]] %in% c("R", "V") ~ .data[["From"]], 
      .data[["Matrix"]] %in% c("U", "Y") ~ .data[["To"]], 
      TRUE ~ NA_character_
    ), 
    # Eliminate unneeded columns.
    From = NULL, 
    To = NULL, 
    Matrix = NULL
  ) |> 
  # Now make the S_units vectors
  IEATools::extract_S_units_from_tidy(matnames = "Matrix", e_dot = "Value")
```

```{targets ruvy_df, tar_simple = TRUE}
iron_steel |> 
  dplyr::group_by(Year, Country, Energy.type, Matrix) |> 
  matsindf::collapse_to_matrices(matnames = "Matrix", 
                                 rownames = "From", 
                                 colnames = "To",
                                 matvals = "Value",
                                 matrix.class = "matrix") |> 
  tidyr::pivot_wider(names_from = "Matrix", values_from = "Value") |> 
  dplyr::mutate(
    # Set row and column types
    R = R |> matsbyname::setrowtype("Industry") |> matsbyname::setcoltype("Product"), 
    U = U |> matsbyname::setrowtype("Product") |> matsbyname::setcoltype("Industry"), 
    V = V |> matsbyname::setrowtype("Industry") |> matsbyname::setcoltype("Product"), 
    Y = Y |> matsbyname::setrowtype("Product") |> matsbyname::setcoltype("Industry")
  ) |> 
  # Join with the S_units matrices
  dplyr::left_join(s_units)
```



# Pipeline

If you ran all the `{targets}` chunks in non-interactive mode, then your R scripts are set up to run the pipeline.

```{r}
tar_make()
```

The `targets` dependency graph shows the steps of the calculation pipeline.

```{r}
tar_visnetwork()
```


# Output

Retrieve results from the `_targets/` data store using `tar_read()`.

```{r, message = FALSE}
df <- tar_read(ruvy_df)
df
```

Look at some of the matrices.

The resource matrix (**R**) contains exogenous inputs to the energy conversion chain.
Imports can also be included here for a single country.
The next bit of code grabs the **R** matrix in the first row (2001).

```{r}
df$R[[1]]
```

The use matrix (**U**) contains all uses of energy by transformation
industries in the economy.
The next bit of code grabs the **U** matrix in the second row (2011).

```{r}
df$U[[2]]
```

The make matrix (**V**) contains all uses of energy by transformation
industries in the economy.
The next bit of code grabs the **V** matrix in the first row (2001).

```{r}
df$V[[1]]
```

The final demand matrix (**Y**) shows sectoral uses of energy.
If we had more than the "Iron and steel" sector,
the **Y** matrix would contain additional columns.
The next bit of code grabs the **Y** matrix in the second row (2011).

```{r}
df$Y[[2]]
```


We can check whether the matrices exhibit energy balance.

```{r}
df |> 
  Recca::verify_SUT_energy_balance() |> 
  dplyr::select(Country, Year, .SUT_energy_balance)
```

We can visualize with Sankey diagrams. 
This code makes a Sankey diagram from each row of the data frame.

```{r}
sankeys <- df |> 
  Recca::make_sankey()
sankeys
```

Here is the Sankey diagram for the first row (2001).

```{r}
sankeys |> 
  dplyr::filter(Year == 2001) |> 
  magrittr::extract2("Sankey") |> 
  magrittr::extract2(1)
```

Here is the Sankey diagram for the second row (2011).

```{r}
sankeys |> 
  dplyr::filter(Year == 2011) |> 
  magrittr::extract2("Sankey") |> 
  magrittr::extract2(1)
```


# Analysis

We can run all types of analyses after the data are in the RUVY format.
For example, this code calculates the efficiency of all Industries.

```{r}
eta_i <- df |>
  Recca::calc_eta_i()
```

The **eta_i** vectors contain efficiencies for each processing stage (Industry) 
in the energy conversion chain.
Here are the efficiencies for 2001.

```{r}
eta_i$eta_i[[1]]
```

And here are the efficiencies for 2011.

```{r}
eta_i$eta_i[[2]]
```

Note that the code to calculate efficiencies applies to the `df` data frame.
Thus, the same code works for any number of rows in the data frame.
I.e., the same code works for any number of countries and years.

Furthermore, the code to calculate efficiencies applies to the **U** and **V** matrices,
regardless of their size. 
So, the same code works if we have more energy carriers or more 
energy transformation industries.


# Questions and comments

(1) There is "Energy industry own use" of "Gross electricity". 
    Which part of the energy industry uses that electricity?
    We will want to route that electricity consumption
    to the actual machine.
(2) We need to synchronize the various "XXX - plant" machine names
    with the names of similar devices in the short run database.
(3) What is meant by "Electronics (if no detail)"? 
    To my knowledge, 
    that machine name is not present in the short run database.
(4) I think we'll need to sort out "Wind", "Wind [from Resources]", 
    "Wind - Turbine", and "Main activity producer electricity plants".
    I think we're using those terms differently in the short run database.
(5) In particular "Wind - Turbine" making "Wind" doesn't seem right.
(6) The "Losses" node seems wrong, as evidenced by the Sankey diagram. 
    We need to figure that out.
(7) Efficiencies are a bit weird. 
    "Losses" acts as an industry, which it should not be.
    "Gas extraction" and "Oil extraction" have an efficiencies of `0`, which is surprising.
    Several other Industries have efficiency of `1`, which needs to be investigated.
(8) The efficiency calculation is a good diagnostic.
    When we see problems with efficiency results, that indicates
    that we have not yet specified the matrices correctly.

    
